import {_ as t} from "https://b.stripecdn.com/mkt-statics-srv/assets/index-133d923f.js";
import {T as i} from "https://b.stripecdn.com/mkt-statics-srv/assets/Timing-1c9d4e8b.js";
import {F as e} from "https://b.stripecdn.com/mkt-statics-srv/assets/index-e07da6fb.js";
import {N as s} from "https://b.stripecdn.com/mkt-statics-srv/assets/Numbers-acd37a6c.js";
import {E as a} from "https://b.stripecdn.com/mkt-statics-srv/assets/Easings-71917624.js";
import {aa as o, G as n, aA as r, aB as h, b as l, t as d, M as c, o as u, aq as m, aC as g, aD as p, q as b, V as f, an as v, C as w, S as y, O as L, W as M, A as C, d as S, T as R, aE as _, aF as x, aG as D, aH as I} from "./three.module-54a2dc38.js";
const G = {
    ad: [42.5, 1.5],
    ae: [24, 54],
    af: [33, 65],
    al: [41, 20],
    am: [40, 45],
    an: [12.25, -68.75],
    ao: [-12.5, 18.5],
    ap: [35, 105],
    aq: [-90, 0],
    ar: [-34, -64],
    at: [47.3333, 13.3333],
    au: [-27, 133],
    aw: [12.5, -69.9667],
    az: [40.5, 47.5],
    ba: [44, 18],
    bd: [24, 90],
    be: [50.8333, 4],
    bf: [13, -2],
    bg: [43, 25],
    bh: [26, 50.55],
    bi: [-3.5, 30],
    bj: [9.5, 2.25],
    bn: [4.5, 114.6667],
    bo: [-17, -65],
    br: [-10, -55],
    bt: [27.5, 90.5],
    bv: [-54.4333, 3.4],
    bw: [-22, 24],
    bz: [17.25, -88.75],
    ca: [54, -100],
    cd: [0, 25],
    cf: [7, 21],
    ch: [47, 8],
    cl: [-30, -71],
    cm: [6, 12],
    cn: [35, 105],
    co: [4, -72],
    cr: [10, -84],
    cy: [35, 33],
    cz: [49.75, 15.5],
    de: [51, 9],
    dj: [11.5, 43],
    dk: [56, 10],
    do: [19, -70.6667],
    dz: [28, 3],
    ec: [-2, -77.5],
    ee: [59, 26],
    eg: [27, 30],
    eh: [24.5, -13],
    er: [15, 39],
    es: [40, -4],
    et: [8, 38],
    eu: [47, 8],
    fi: [64, 26],
    fo: [62, -7],
    fr: [46, 2],
    ga: [-1, 11.75],
    gb: [54, -2],
    ge: [42, 43.5],
    gf: [4, -53],
    gh: [8, -2],
    gi: [36.1833, -5.3667],
    gl: [72, -40],
    gm: [13.4667, -16.5667],
    gn: [11, -10],
    gq: [2, 10],
    gr: [39, 22],
    gt: [15.5, -90.25],
    gw: [12, -15],
    gy: [5, -59],
    hk: [22.25, 114.1667],
    hn: [15, -86.5],
    hr: [45.1667, 15.5],
    ht: [19, -72.4167],
    hu: [47, 20],
    id: [-5, 120],
    ie: [53, -8],
    il: [31.5, 34.75],
    in: [20, 77],
    is: [65, -18],
    it: [42.8333, 12.8333],
    jm: [18.25, -77.5],
    jo: [31, 36],
    jp: [36, 138],
    ke: [1, 38],
    kg: [41, 75],
    kh: [13, 105],
    kr: [37, 127.5],
    kw: [29.3375, 47.6581],
    kz: [48, 68],
    la: [18, 105],
    lb: [33.8333, 35.8333],
    li: [47.1667, 9.5333],
    lk: [7, 81],
    ls: [-29.5, 28.5],
    lt: [56, 24],
    lu: [49.75, 6.1667],
    lv: [57, 25],
    ly: [25, 17],
    ma: [32, -5],
    mc: [43.7333, 7.4],
    md: [47, 29],
    me: [42, 19],
    mg: [-20, 47],
    mk: [41.8333, 22],
    ml: [17, -4],
    mn: [46, 105],
    mo: [22.1667, 113.55],
    mr: [20, -12],
    mw: [-13.5, 34],
    mx: [23, -102],
    my: [2.5, 112.5],
    mz: [-18.25, 35],
    na: [-22, 17],
    ne: [16, 8],
    ng: [10, 8],
    ni: [13, -85],
    nl: [52.5, 5.75],
    no: [62, 10],
    np: [28, 84],
    nz: [-41, 174],
    om: [21, 57],
    pa: [9, -80],
    pe: [-10, -76],
    pg: [-6, 147],
    ph: [13, 122],
    pk: [30, 70],
    pl: [52, 20],
    pm: [46.8333, -56.3333],
    ps: [32, 35.25],
    pt: [39.5, -8],
    py: [-23, -58],
    qa: [25.5, 51.25],
    ro: [46, 25],
    rs: [44, 21],
    ru: [60, 100],
    rw: [-2, 30],
    sa: [25, 45],
    se: [62, 15],
    sg: [1.3667, 103.8],
    si: [46, 15],
    sj: [78, 20],
    sk: [48.6667, 19.5],
    sl: [8.5, -11.5],
    sm: [43.7667, 12.4167],
    sn: [14, -14],
    so: [10, 49],
    sr: [4, -56],
    sv: [13.8333, -88.9167],
    sz: [-26.5, 31.5],
    td: [15, 19],
    tg: [8, 1.1667],
    th: [15, 100],
    tj: [39, 71],
    tn: [34, 9],
    tr: [39, 35],
    tt: [11, -61],
    tw: [23.5, 121],
    tz: [-6, 35],
    ua: [49, 32],
    ug: [1, 32],
    us: [38, -97],
    uy: [-33, -56],
    uz: [41, 64],
    va: [41.9, 12.45],
    ve: [8, -66],
    vn: [16, 106],
    ye: [15, 48],
    za: [-29, 24],
    zm: [-15, 30]
}
  , z = Math.PI
  , k = z / 2
  , T = 180 / z
  , A = z / 180
  , O = Math.atan2
  , F = Math.cos
  , X = Math.sin
  , Y = Math.sqrt;
function E(t) {
    return (t = X(t / 2)) * t
}
function P(t, i) {
    const e = t[0] * A
      , s = t[1] * A
      , a = i[0] * A
      , o = i[1] * A
      , n = F(s)
      , r = X(s)
      , h = F(o)
      , l = X(o)
      , d = n * F(e)
      , c = n * X(e)
      , u = h * F(a)
      , m = h * X(a)
      , g = 2 * ((p = Y(E(o - s) + n * h * E(a - e))) > 1 ? k : p < -1 ? -k : Math.asin(p));
    var p;
    const b = X(g)
      , f = g ? function(t) {
        const i = X(t *= g) / b
          , e = X(g - t) / b
          , s = e * d + i * u
          , a = e * c + i * m
          , o = e * r + i * l;
        return [O(a, s) * T, O(o, Y(s * s + a * a)) * T]
    }
    : function() {
        return [e * T, s * T]
    }
    ;
    return f.distance = g,
    f
}
const B = Math.PI / 180;
function j(t, i, e) {
    const s = (90 - t) * B
      , a = i * B;
    return new o(-e * Math.sin(s) * Math.cos(a),e * Math.cos(s),e * Math.sin(s) * Math.sin(a))
}
class W extends n {
    constructor(i, e, n, g, p, b, f, v, w=1) {
        super(),
        t(this, "animationFrame", void 0),
        t(this, "drawAnimatedLine", ()=>{
            if (!this.active)
                return;
            let t = this.geometry.drawRange.count;
            const i = performance.now() - this.startTime;
            this.material.uniforms.u_time.value = i;
            const e = a.easeOutQuart(i, 0, 1, 2500);
            if (t = Math.min(3e3, Math.ceil(3e3 * e)),
            this.active && t < 3e3) {
                const i = this.circle1.scale.x;
                if (i < .35 && this.circle1.scale.set(i + .01, i + .01, i + .01),
                t > 1500) {
                    const t = this.circle2.scale.x;
                    t < .35 && this.circle2.scale.set(t + .015, t + .015, t + .015)
                }
                this.geometry.setDrawRange(0, t)
            }
            this.animationFrame = requestAnimationFrame(this.drawAnimatedLine)
        }
        ),
        t(this, "drawStaticLine", ()=>{
            this.geometry.setDrawRange(0, 3e3),
            this.circle1.scale.set(.35, .35, .35),
            this.circle2.scale.set(.35, .35, .35)
        }
        ),
        t(this, "eraseLine", ()=>{
            const t = this.geometry.drawRange.count
              , i = this.geometry.drawRange.start;
            if (this.material.uniforms.u_time.value = performance.now() - this.startTime,
            i > t)
                return;
            const e = this.circle1.scale.x
              , s = this.circle2.scale.x;
            if (e > .03) {
                const t = e - .01;
                this.circle1.scale.set(t, t, t)
            }
            if (i > 1500 && s > .03) {
                const t = s - .015;
                this.circle2.scale.set(t, t, t)
            }
            this.geometry.setDrawRange(i + 48, t),
            this.animationFrame = requestAnimationFrame(this.eraseLine)
        }
        ),
        this.colors = n,
        this.texture = g,
        this.isStatic = v,
        this.startLat = i[0],
        this.startLng = i[1];
        const y = e[0]
          , L = e[1]
          , M = j(this.startLat, this.startLng, b)
          , C = j(y, L, 1.002 * b)
          , S = s.clamp(.5 * M.distanceTo(C), 160, 500)
          , R = P([this.startLng, this.startLat], [L, y])
          , _ = R(.25)
          , x = R(.75)
          , D = j(_[1], _[0], b + S)
          , I = j(x[1], x[0], b + S)
          , G = new r(M,D,I,C);
        this.geometry = new h(G,44,.2 + b / 1200 * f,8,!1),
        this.material = new l({
            uniforms: {
                u_time: {
                    type: "f",
                    value: 0
                },
                u_alpha: {
                    type: "f",
                    value: w
                },
                u_texture: {
                    type: "t",
                    value: null
                },
                speedEpsilon: {
                    type: "f",
                    value: 4e-4
                }
            },
            vertexShader: "\n        varying vec2 vUv;\n\n        void main() {\n          vUv = uv;\n          gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);\n        }\n      ",
            fragmentShader: "\n        uniform float u_time;\n        uniform float u_alpha;\n        uniform sampler2D u_texture;\n        varying vec2 vUv;\n        uniform float speedEpsilon;\n\n        void main() {\n          float ramp = vUv.x * 0.5;\n          float pct = fract(ramp - u_time * speedEpsilon);\n          vec4 color = texture2D(u_texture, vec2(pct, 0.6));\n          color.a = u_alpha;\n          gl_FragColor = vec4(color);\n        }\n      "
        }),
        this.active = !1,
        this.mesh = new d(this.geometry,this.material),
        this.add(this.mesh),
        this.material.uniforms.u_texture.value = this.texture,
        this.circleMaterial1 = new c({
            map: p,
            color: n[0],
            transparent: !0,
            opacity: w,
            side: u
        }),
        this.circleMaterial2 = new c({
            map: p,
            color: n[1],
            transparent: !0,
            opacity: w,
            side: u
        }),
        this.circleGeometry = new m(.1 * b,.1 * b,2),
        this.circle1 = new d(this.circleGeometry,this.circleMaterial1),
        this.circle2 = new d(this.circleGeometry,this.circleMaterial2),
        this.circle1.scale.set(.01, .01, .01),
        this.circle2.scale.set(.01, .01, .01),
        this.circle1.position.set(M.x, M.y, M.z),
        this.circle2.position.set(C.x, C.y, C.z),
        this.circle1.rotation.set(Math.PI, Math.PI, Math.PI),
        this.circle2.rotation.set(Math.PI, Math.PI, Math.PI),
        this.circle1.lookAt(new o(0,0,0)),
        this.circle2.lookAt(new o(0,0,0)),
        this.add(this.circle1),
        this.add(this.circle2),
        this.showLine()
    }
    showLine() {
        this.active = !0,
        this.geometry.setDrawRange(0, 1),
        this.isStatic ? this.drawStaticLine() : (this.startTime = performance.now(),
        this.drawAnimatedLine())
    }
    hideLine() {
        this.active = !1,
        this.eraseLine()
    }
    disposeLine() {
        this.mesh.geometry.dispose(),
        this.texture.dispose(),
        this.mesh.material.dispose(),
        this.circle1.geometry.dispose(),
        this.circle1.material.dispose(),
        this.circle2.geometry.dispose(),
        this.circle2.material.dispose(),
        this.children = null
    }
    pause() {
        cancelAnimationFrame(this.animationFrame)
    }
    play() {
        this.isStatic ? this.drawStaticLine() : this.active ? this.animationFrame = requestAnimationFrame(this.drawAnimatedLine) : this.animationFrame = requestAnimationFrame(this.eraseLine)
    }
}
function q(t, i) {
    const e = new o;
    e.subVectors(i, t).normalize();
    const s = 1 - (.5 + Math.atan2(e.z, e.x) / (2 * Math.PI))
      , a = .5 + Math.asin(e.y) / Math.PI;
    return new f(s,a)
}
function V(t, i) {
    const e = i.width
      , s = i.height
      , a = 4 * Math.floor(t.x * e) + Math.floor(t.y * s) * (4 * e);
    return i.data.slice(a, a + 4)
}
class U extends n {
    constructor(i) {
        super(),
        t(this, "callback", void 0),
        this.callback = i.callback,
        this.isStatic = i.isStatic,
        this.dotDensity = i.dotDensity,
        this.dotSize = i.dotSize,
        this.dotSideCount = i.dotSideCount,
        this.dotColor = i.dotColor,
        this.radius = i.radius,
        this.rotation.x = -Math.PI,
        this.rotation.z = -Math.PI,
        this.isDragging = !1,
        this.dragTime = 0,
        this.loadImage()
    }
    loadImage() {
        (new g).load("https://images.ctfassets.net/fzn2n1nzq965/11064gUb2CgTJXKVwAt5J9/297a98a65d04d4fbb979072ce60466ab/map_fill-a78643e8.png", t=>{
            this.imageData = function(t) {
                const i = t.width
                  , e = t.height
                  , s = document.createElement("canvas");
                s.width = i,
                s.height = e;
                const a = s.getContext("2d");
                return a.drawImage(t, 0, 0),
                a.getImageData(0, 0, i, e)
            }(t),
            this.initDots()
        }
        )
    }
    initDots() {
        const t = this.radius / 450
          , i = this.radius / 600 * this.dotDensity
          , e = Math.floor(7e4 * i)
          , s = this.radius
          , a = new p(this.dotSize * t,this.dotSideCount)
          , n = new b
          , r = []
          , h = []
          , c = new o;
        for (let t = e; t >= 0; t -= 1) {
            const i = Math.acos(2 * t / e - 1)
              , o = Math.sqrt(e * Math.PI) * i;
            c.setFromSphericalCoords(s, i, o),
            n.copy(a),
            n.lookAt(c),
            n.translate(c.x, c.y, c.z),
            n.computeBoundingSphere();
            if (V(q(n.boundingSphere.center, this.position), this.imageData)[3] > 0) {
                const t = Math.random();
                for (let i = 0; i < this.dotSideCount; i += 1)
                    r.push(n.attributes.position.array[0], n.attributes.position.array[1], n.attributes.position.array[2], n.attributes.position.array[3 + 3 * i], n.attributes.position.array[4 + 3 * i], n.attributes.position.array[5 + 3 * i], n.attributes.position.array[6 + 3 * i], n.attributes.position.array[7 + 3 * i], n.attributes.position.array[8 + 3 * i]),
                    h.push(t, t, t);
                r.push(n.attributes.position.array[0], n.attributes.position.array[1], n.attributes.position.array[2], n.attributes.position.array[3], n.attributes.position.array[4], n.attributes.position.array[5], n.attributes.position.array[3 + 3 * this.dotSideCount], n.attributes.position.array[4 + 3 * this.dotSideCount], n.attributes.position.array[5 + 3 * this.dotSideCount]),
                h.push(t, t, t)
            }
        }
        const m = new b;
        m.setAttribute("position", new v(r,3)),
        m.setAttribute("rndId", new v(h,1)),
        this.material = new l({
            side: u,
            transparent: !0,
            uniforms: {
                u_time: {
                    type: "f",
                    value: 0
                },
                u_drag_time: {
                    type: "f",
                    value: 0
                },
                u_resolution: {
                    type: "v2",
                    value: new f
                },
                u_r: {
                    type: "f",
                    value: this.dotColor.r
                },
                u_g: {
                    type: "f",
                    value: this.dotColor.g
                },
                u_b: {
                    type: "f",
                    value: this.dotColor.b
                },
                u_z_offset_factor: {
                    type: "f",
                    value: 0
                },
                u_opacity_factor: {
                    type: "f",
                    value: 1
                }
            },
            vertexShader: "\n        uniform float u_time;\n        uniform float u_drag_time;\n        uniform vec2 u_resolution;\n        uniform float u_z_offset_factor;\n        attribute float rndId;\n        varying float vRndId;\n\n        varying float pct;\n\n        void main() {\n          vRndId = rndId;\n          vec2 st = position.xy/u_resolution;\n\n          pct = min(1.0, u_time / (1000. / max(0.2, 0.2 * sin(fract(rndId)))));\n          float vNormal = 1.0;\n          if (u_drag_time > 0.) {\n            vNormal -= ((sin(u_time / 400.0 * vRndId) + 1.0) * 0.02) * min(1., u_drag_time / 1200.0);\n          }\n          vNormal -= ((sin(u_time / 400.0 * vRndId) + 1.0) * 0.02) * u_z_offset_factor;\n          vec4 modelViewPosition = modelViewMatrix * vec4(position, vNormal);\n          gl_Position = projectionMatrix * modelViewPosition;\n        }\n    ",
            fragmentShader: "\n        uniform bool u_dragging;\n        uniform float u_time;\n        uniform float u_drag_time;\n        uniform float u_r;\n        uniform float u_g;\n        uniform float u_b;\n        uniform float u_opacity_factor;\n        varying float vRndId;\n        varying float pct;\n\n        void main() {\n          float v = sin(u_time / 200.0 * vRndId);\n          float alpha = (pct * 0.7 + v * 0.2) * u_opacity_factor;\n          float dragDur = 1200.0;\n          vec3 color = vec3(u_r, u_g, u_b);\n          float rInc = min(1.0, u_drag_time / dragDur) * (sin(u_drag_time / (dragDur * 0.5) + 1.0) * 0.1);\n          float gInc = min(1.0, u_drag_time / dragDur) * (sin(u_drag_time / (dragDur * 0.75) - 1.0) * 0.1);\n          float bInc = min(1.0, u_drag_time / dragDur) * (sin(u_drag_time / dragDur) * 0.1);\n          if (u_dragging) {\n            color.r = u_r + rInc;\n            color.g = u_g + gInc;\n            color.b = u_b + bInc;\n          }\n\n          gl_FragColor = vec4(color, alpha);\n        }\n    "
        });
        const g = new d(m,this.material);
        this.remove(this.children[0]),
        this.add(g),
        this.material.uniforms.u_resolution.value.x = window.innerWidth,
        this.material.uniforms.u_resolution.value.y = window.innerHeight,
        this.startTime = performance.now(),
        this.dragStartTime = 0,
        this.callback()
    }
    startDragging() {
        this.material && !this.isStatic && (this.isDragging = !0,
        this.dragStartTime = performance.now(),
        this.material.uniforms.u_time.value = performance.now() - this.dragStartTime)
    }
    stopDragging() {
        this.isDragging = !1
    }
    updateDragTimer() {
        this.isDragging ? this.dragTime = performance.now() - this.dragStartTime : this.dragTime > .1 && (this.dragTime = Math.max(0, .9 * this.dragTime))
    }
    animate() {
        if (this.updateDragTimer(),
        !this.material)
            return;
        this.material.uniforms.u_drag_time.value = this.dragTime;
        const t = this.isStatic ? 3e3 : performance.now() - this.startTime;
        this.material.uniforms.u_time.value = t
    }
}
const H = 2 * Math.PI
  , N = .1111 * Math.PI
  , Q = Math.PI
  , K = .1 * Math.PI
  , Z = new w(1056824)
  , J = new w(15857141)
  , $ = new w(11783423)
  , tt = new w(3173286)
  , it = -.5 * Math.PI
  , et = .25 * Math.PI
  , st = ["https://images.ctfassets.net/fzn2n1nzq965/21KQEBsC7QG4IYZV5RuhDz/d3180249af4082f42a22cb5f3ccc8e09/arc-texture-1.png", "https://images.ctfassets.net/fzn2n1nzq965/22Apsqcv7VIDzlCuSOEzPQ/2194c40aac8bced46d48582d5d712bf6/arc-texture-2.png", "https://images.ctfassets.net/fzn2n1nzq965/79YUdAMNjtlQuuFLN0RBLG/f779fbfcc31d6360893844a29ec5fb4f/arc-texture-3.png", "https://images.ctfassets.net/fzn2n1nzq965/7ez6kk9Dk9uuhgdRLFyhZX/220a177ca8529de208f8ae3cc3b10609/arc-texture-4.png"]
  , at = [[16335176, 16763735], [11232234, 9494783], [16335176, 11232234], [16763735, 9494783]]
  , ot = ["https://images.ctfassets.net/fzn2n1nzq965/3VtESM8wPIKF3CZXhz1tSc/03f35aa0452b6edc6a9f6c105ef97ca2/512_x_512__1_.png"];
class nt {
    constructor(i, s={}) {
        t(this, "el", void 0),
        t(this, "eastCountryList", ["my", "sg", "au", "nz", "hk", "jp", "in"]),
        t(this, "westCountryList", ["ca", "mx", "us", "br"]),
        t(this, "middleCountryList", ["be", "gb", "at", "dk", "ee", "fi", "fr", "gr", "de", "ie", "it", "lv", "lt", "lu", "nl", "no", "pl", "pt", "es", "sk", "si", "se", "ch", "cy", "bg", "ro", "cz"]),
        t(this, "liveCountryList", [...this.eastCountryList, ...this.westCountryList, ...this.middleCountryList]),
        t(this, "countryList", Object.keys(G)),
        t(this, "origin", new o(0,0,0)),
        t(this, "dom", {}),
        t(this, "mouse", new f),
        t(this, "isDragging", !1),
        t(this, "isStatic", e.disableAmbientAnimations()),
        t(this, "isDiscTextureLoaded", !1),
        t(this, "arcTexturesLoaded", 0),
        t(this, "globeOff", !1),
        t(this, "scrollTop", 0),
        t(this, "opacityLoadPercent", 0),
        t(this, "targetOpacityBase", void 0),
        t(this, "targetDotOpacityBase", 1),
        t(this, "targetOpacityScrollAmount", 0),
        t(this, "targetOpacity", 1),
        t(this, "lineCount", 0),
        t(this, "linesOff", !1),
        t(this, "arcColors", void 0),
        t(this, "arcTextures", void 0),
        t(this, "scene", new y),
        t(this, "globeRadius", 250 + .3 * Math.min(document.documentElement.clientWidth, 1080)),
        t(this, "globeSegments", Math.floor(this.globeRadius / 250 * 10) + 20),
        t(this, "isLoaded", !1),
        t(this, "loaded", []),
        t(this, "loading", []),
        t(this, "isScrolling", !1),
        t(this, "isRevealed", !1),
        t(this, "frame", 0),
        t(this, "touchDistanceX", void 0),
        t(this, "touchStartX", void 0),
        t(this, "touchDistanceY", void 0),
        t(this, "touchStartY", void 0),
        t(this, "oldRotationY", 0),
        t(this, "oldRotationX", 0),
        t(this, "newRotationY", 0),
        t(this, "newRotationX", 0),
        t(this, "globeRotationIncrement", .02),
        t(this, "globeRotationBase", 0),
        t(this, "globeRotationScrollAmount", 0),
        t(this, "targetScale", 1),
        t(this, "scale", void 0),
        t(this, "oldMouseX", 0),
        t(this, "oldMouseY", 0),
        t(this, "moveX", 0),
        t(this, "moveY", 0),
        t(this, "tension", 1),
        t(this, "arcTextureUrls", void 0),
        t(this, "arcTextures", void 0),
        t(this, "arcThicknessMultiplier", 1),
        t(this, "windowW", void 0),
        t(this, "windowH", void 0),
        t(this, "aspectRatio", void 0),
        t(this, "oldInnerWidth", void 0),
        t(this, "camera", void 0),
        t(this, "cameraXBase", 0),
        t(this, "cameraXScrollAmount", 0),
        t(this, "cameraYBase", 0),
        t(this, "cameraYScrollAmount", 0),
        t(this, "renderer", void 0),
        t(this, "globeContainer", void 0),
        t(this, "globeAlignment", void 0),
        t(this, "moveGlobeToTopAmount", void 0),
        t(this, "globeDots", void 0),
        t(this, "globeFillMaterial", void 0),
        t(this, "globeFillSphere", void 0),
        t(this, "globeFill", void 0),
        t(this, "globeMap", void 0),
        t(this, "globeColorRgb", void 0),
        t(this, "dotColorRgb", void 0),
        t(this, "circleTexture", void 0),
        t(this, "linesContainer", void 0),
        t(this, "lineInterval", void 0),
        t(this, "ambientLight", void 0),
        t(this, "backLight", void 0),
        t(this, "frontLight", void 0),
        t(this, "ambientLightColor", void 0),
        t(this, "backLightColor", void 0),
        t(this, "frontLightColor", void 0),
        t(this, "renderAnimationFrame", void 0),
        t(this, "throwAnimationFrame", void 0),
        t(this, "initialized", !1),
        t(this, "currentLines", []),
        t(this, "pauseRotate", void 0),
        t(this, "linesInitialized", !1),
        t(this, "customRevealAnimation", void 0),
        t(this, "backgroundGradientSize", 1),
        t(this, "backgroundGradient", void 0),
        t(this, "backgroundGradientUrl", void 0),
        t(this, "initGlobeOptions", {
            antialias: !1,
            pauseRotate: !1,
            linesOff: !1,
            customRevealAnimation: null,
            opacity: .94,
            ambientIntensity: 1,
            backIntensity: 2,
            frontIntensity: .8,
            globeScale: 1,
            dotDensity: 1,
            dotSize: 1.8,
            dotSideCount: 5,
            globeAlignment: "center"
        }),
        t(this, "handleDragStart", ()=>{
            this.globeDots.startDragging(),
            this.isDragging = !0,
            this.oldRotationX = this.globeContainer.rotation.x,
            this.oldRotationY = this.globeRotationBase,
            this.targetScale = this.isStatic ? 1 : .98,
            document.documentElement.classList.add("is-globe-dragging")
        }
        ),
        t(this, "handleTouchStart", t=>{
            const i = t.touches[0] || t.changedTouches[0];
            this.oldMouseX = i.pageX,
            this.oldMouseY = i.pageY,
            this.mouse.x = i.pageX,
            this.mouse.y = i.pageY,
            this.touchStartX = i.pageX,
            this.touchStartY = i.pageY,
            this.handleDragStart()
        }
        ),
        t(this, "handleMouseMove", t=>{
            this.mouse.x = t.clientX,
            this.mouse.y = t.clientY,
            this.handleDragging()
        }
        ),
        t(this, "handleTouchMove", t=>{
            const i = t.touches[0] || t.changedTouches[0];
            this.touchDistanceX = Math.abs(this.touchStartX - i.pageX),
            this.touchDistanceY = Math.abs(this.touchStartY - i.pageY),
            this.touchDistanceY > this.touchDistanceX || (this.mouse.x = i.pageX,
            this.mouse.y = i.pageY,
            this.handleDragging())
        }
        ),
        t(this, "handleMouseUp", ()=>{
            setTimeout(()=>{
                document.documentElement.classList.remove("is-globe-dragging")
            }
            , 20),
            this.isDragging = !1,
            (0 !== this.moveX || Math.abs(this.moveY) > 0) && this.throwGlobe(this.moveX, this.moveY),
            this.oldMouseX = 0,
            this.oldMouseY = 0,
            this.moveX = 0,
            this.moveY = 0,
            this.targetScale = 1,
            this.globeDots.stopDragging()
        }
        ),
        t(this, "handleMouseDown", t=>{
            document.documentElement.classList.add("is-globe-dragging"),
            this.oldMouseX = t.clientX,
            this.oldMouseY = t.clientY,
            this.handleDragStart()
        }
        ),
        t(this, "handleDragging", ()=>{
            this.isDragging && (this.tension = 1 + Math.abs(this.oldRotationX),
            this.tension **= this.tension,
            this.moveX = -.003 * (this.oldMouseX - this.mouse.x),
            this.moveY = -.003 * (this.oldMouseY - this.mouse.y) / this.tension,
            this.newRotationY = this.resetRevolutions(this.oldRotationY + this.moveX),
            this.newRotationX = Math.max(it, Math.min(et, this.oldRotationX + this.moveY)),
            this.globeContainer.rotation.y = this.newRotationY,
            this.globeRotationBase = this.newRotationY,
            this.globeContainer.rotation.x = this.newRotationX,
            this.oldRotationY = this.newRotationY,
            this.oldRotationX = this.newRotationX,
            this.oldMouseX = this.mouse.x,
            this.oldMouseY = this.mouse.y)
        }
        ),
        t(this, "setWindowSize", ()=>{
            this.windowW = document.documentElement.clientWidth,
            this.windowH = this.el.offsetHeight,
            this.aspectRatio = this.windowW / this.windowH,
            this.renderer.setSize(this.windowW, this.windowH),
            this.oldInnerWidth = this.windowW,
            "top" === this.globeAlignment && (this.moveGlobeToTopAmount = -this.windowH / 2 + .65 * this.globeRadius)
        }
        ),
        t(this, "handleResize", ()=>{
            const t = document.documentElement.clientWidth;
            (this.oldInnerWidth !== t || t > 512) && (this.setWindowSize(),
            this.addCamera())
        }
        ),
        this.el = i,
        Object.entries(s).forEach(([t,i])=>{
            this.initGlobeOptions[t] = i
        }
        ),
        this.pauseRotate = this.initGlobeOptions.pauseRotate,
        this.linesOff = this.initGlobeOptions.linesOff,
        this.customRevealAnimation = this.initGlobeOptions.customRevealAnimation;
        const a = this.getInitVal("theme", "White" === this.el.dataset.jsGlobeTheme ? "White" : "Dark");
        this.globeAlignment = "top" === this.initGlobeOptions.globeAlignment ? "top" : "center";
        const n = this.getInitVal("globePosition", "BottomCenter" === this.el.dataset.jsGlobePosition ? "BottomCenter" : "BottomRight");
        this.globeColorRgb = this.getInitVal("globeColor", "White" === a ? J : Z),
        this.dotColorRgb = this.getInitVal("dotColor", "White" === a ? $ : tt),
        this.cameraXBase = this.getInitVal("cameraXBase", "BottomCenter" === n ? -.4 * this.globeRadius : -1.05 * this.globeRadius),
        this.cameraYBase = this.getInitVal("cameraYBase", "BottomCenter" === n ? .5 * this.globeRadius : .2 * this.globeRadius),
        this.ambientLightColor = this.getInitVal("ambientLight", "White" === a ? 14542575 : 10086140),
        this.backLightColor = this.getInitVal("backLight", "White" === a ? 2236962 : 12775677),
        this.frontLightColor = this.getInitVal("frontLight", "White" === a ? 4473935 : 10593711),
        this.scale = this.initGlobeOptions.globeScale,
        null != s.backgroundGradient && (this.backgroundGradientUrl = ot[s.backgroundGradient]),
        this.arcTextureUrls = s.arcTextures ? s.arcTextures : st,
        this.arcColors = s.arcColors ? s.arcColors : at,
        s.arcThicknessMultiplier && (this.arcThicknessMultiplier = s.arcThicknessMultiplier)
    }
    getInitVal(t, i) {
        if (Object.prototype.hasOwnProperty.call(this.initGlobeOptions, t)) {
            const i = this.initGlobeOptions[t];
            return !t.includes("Color") || "number" != typeof i && "string" != typeof i ? t.includes("camera") ? this.globeRadius * i : i : new w(i)
        }
        return i
    }
    load() {
        return this.loading.push("scene"),
        this.el.style.height = window.outerHeight,
        this.dom.container = this.el,
        this.addRenderer(this.initGlobeOptions.antialias),
        this.addLighting(),
        this.addGlobe(),
        this.addListeners(),
        this.setWindowSize(),
        this.addCamera(),
        this.objectLoaded("scene"),
        !0
    }
    play() {
        this.initialized && !this.isStatic ? (this.currentLines.forEach(t=>t.play()),
        this.drawLines()) : this.addLines(),
        this.initialized && this.isStatic || this.render(this.frame),
        this.initialized = !0
    }
    pause() {
        this.currentLines.forEach(t=>t.pause()),
        cancelAnimationFrame(this.renderAnimationFrame),
        clearInterval(this.lineInterval)
    }
    disconnect() {
        clearInterval(this.lineInterval),
        cancelAnimationFrame(this.renderAnimationFrame),
        cancelAnimationFrame(this.throwAnimationFrame),
        window.removeEventListener("resize", this.handleResize),
        this.isStatic || (window.removeEventListener("mouseup", this.handleMouseUp),
        window.removeEventListener("mousemove", this.handleMouseMove),
        this.el.removeEventListener("touchstart", this.handleTouchStart),
        window.removeEventListener("touchmove", this.handleTouchMove),
        window.removeEventListener("touchend", this.handleMouseUp),
        this.el.removeEventListener("mousedown", this.handleMouseDown))
    }
    setCountryList(t) {
        this.countryList = t
    }
    addCamera() {
        const t = .5 * this.windowH
          , i = -this.aspectRatio * this.windowH * .5
          , e = 4 * this.globeRadius;
        this.camera || (this.camera = new L(0,0,0,0,0,0)),
        this.camera.left = i,
        this.camera.right = -i,
        this.camera.top = t,
        this.camera.bottom = -t,
        this.camera.near = -e,
        this.camera.far = e,
        this.shiftCamera(),
        this.camera.updateProjectionMatrix()
    }
    shiftCamera() {
        this.camera.position.x = this.cameraXBase + this.cameraXScrollAmount,
        this.camera.position.y = this.cameraYBase + this.cameraYScrollAmount,
        "top" === this.globeAlignment && (this.camera.position.y += this.moveGlobeToTopAmount)
    }
    addRenderer(t) {
        this.renderer && this.dom.container.removeChild(this.renderer.domElement),
        this.renderer = new M({
            antialias: t,
            alpha: !0
        }),
        this.renderer.setPixelRatio(window.devicePixelRatio),
        this.renderer.setClearColor(14540253, 0),
        this.renderer.sortObjects = !1,
        this.dom.container.appendChild(this.renderer.domElement)
    }
    addLighting() {
        this.ambientLight = new C(this.ambientLightColor,this.initGlobeOptions.ambientIntensity),
        this.scene.add(this.ambientLight),
        this.backLight = new S(this.backLightColor,this.initGlobeOptions.backIntensity,0,2),
        this.backLight.position.set(-1e3, -1100, -3300),
        this.scene.add(this.backLight),
        this.frontLight = new S(this.frontLightColor,this.initGlobeOptions.frontIntensity,0,20),
        this.frontLight.position.set(-3e3, 3e3, 3300),
        this.scene.add(this.frontLight)
    }
    addGlobe() {
        this.globeContainer = new n,
        this.scene.add(this.globeContainer),
        this.addGlobeBackgroundGradient(),
        this.addGlobeMap(),
        this.addGlobeDots(),
        this.addGlobeFill(),
        this.globeContainer.position.z = 2 * -this.globeRadius,
        this.globeContainer.rotation.x = N,
        this.globeContainer.rotation.y = this.isStatic ? K : Q
    }
    addGlobeBackgroundGradient() {
        if (this.backgroundGradientUrl) {
            this.loading.push("backgroundGradient");
            const t = (new R).load(this.backgroundGradientUrl, ()=>{
                this.objectLoaded("backgroundGradient")
            }
            );
            this.backgroundGradientSize = 2.8 * this.globeRadius;
            const i = new _({
                map: t,
                opacity: 0
            });
            this.backgroundGradient = new x(i),
            this.backgroundGradient.scale.set(this.backgroundGradientSize, this.backgroundGradientSize),
            this.backgroundGradient.renderOrder = 1,
            i.depthTest = !1,
            this.globeContainer.add(this.backgroundGradient)
        }
    }
    addGlobeDots() {
        this.loading.push("globeDots"),
        this.globeDots = new U({
            radius: this.globeRadius,
            callback: ()=>{
                this.objectLoaded("globeDots")
            }
            ,
            isStatic: this.isStatic,
            dotColor: this.dotColorRgb,
            dotDensity: this.initGlobeOptions.dotDensity,
            dotSize: this.initGlobeOptions.dotSize,
            dotSideCount: this.initGlobeOptions.dotSideCount
        }),
        this.globeMap.add(this.globeDots)
    }
    addGlobeFill() {
        this.globeFillMaterial = new D({
            transparent: !0,
            opacity: 0,
            color: this.globeColorRgb
        }),
        this.globeFillSphere = new I(this.globeRadius - .1,this.globeSegments,this.globeSegments),
        this.globeFill = new d(this.globeFillSphere,this.globeFillMaterial),
        this.globeMap.add(this.globeFill)
    }
    addGlobeMap() {
        this.globeMap = new n,
        this.globeContainer.add(this.globeMap)
    }
    throwGlobe(t, i) {
        const e = .94 * t
          , s = .94 * i
          , a = this.globeRotationBase + e
          , o = Math.max(it, Math.min(et, this.globeContainer.rotation.x + s));
        this.globeRotationBase = this.resetRevolutions(a),
        this.globeContainer.rotation.x = o,
        (Math.abs(e) > .001 || Math.abs(s) > .001) && !1 === this.isDragging && (this.throwAnimationFrame = requestAnimationFrame(()=>{
            this.throwGlobe(e, s)
        }
        ))
    }
    addLines() {
        this.linesOff || (this.linesInitialized = !0,
        this.circleTexture = (new R).load("https://images.ctfassets.net/fzn2n1nzq965/2wn0qc94lx6dbfTVt1vpuO/cf3e66080a3cddeb7275a8fefbca5134/disc_texture.png", ()=>{
            this.isDiscTextureLoaded = !0
        }
        ),
        this.arcTextures = this.arcTextureUrls.map(t=>(new R).load(t, ()=>{
            this.arcTexturesLoaded += 1
        }
        )),
        this.linesContainer = new n,
        this.globeContainer.add(this.linesContainer),
        this.drawLines())
    }
    drawLines() {
        if (!this.linesOff)
            if (this.linesInitialized) {
                if (!this.isStatic)
                    return clearInterval(this.lineInterval),
                    void (this.lineInterval = window.setInterval(()=>{
                        this.linesOff || this.drawLine()
                    }
                    , 1e3));
                if (0 === this.lineCount)
                    for (let t = 0; t < 5; t += 1)
                        this.drawLine()
            } else
                this.addLines()
    }
    drawLine() {
        this.lineCount += 1;
        const t = this.resetRevolutions(this.globeContainer.rotation.y);
        let e = this.countryList[this.lineCount % this.countryList.length]
          , s = this.liveCountryList[this.lineCount % this.liveCountryList.length];
        if (t < 5.7 && t > 4.4 || t > -2 && t < -.2 ? s = this.eastCountryList[this.lineCount % this.eastCountryList.length] : t < 4.2 && t > 2.2 || t > -4 && t < -1.7 ? ((t < -1.7 && t > -3 || t > 3 && t < 4.2) && (e = this.eastCountryList[this.lineCount % this.eastCountryList.length]),
        s = this.westCountryList[this.lineCount % this.westCountryList.length]) : (t < 2.2 && t > .3 || t > -6.28 && t < -4) && (s = this.middleCountryList[this.lineCount % this.middleCountryList.length]),
        e === s)
            return void this.drawLine();
        const a = G[e]
          , o = G[s]
          , n = this.lineCount % this.arcColors.length
          , r = this.arcColors[n]
          , h = new W(a,o,r,this.arcTextures[n],this.circleTexture,1.001 * this.globeRadius + .01 * Math.random(),this.arcThicknessMultiplier,this.isStatic,this.targetOpacity);
        this.linesContainer.add(h),
        this.currentLines.push(h),
        this.isStatic || i.delay(()=>{
            this.hideLine(h);
            const t = this.currentLines.indexOf(h);
            t > -1 && this.currentLines.splice(t, 1)
        }
        , 4e3)
    }
    hideLine(t) {
        t.hideLine(),
        i.delay(()=>{
            t.disposeLine(),
            this.linesContainer.remove(t)
        }
        , 1500)
    }
    objectLoaded(t="x") {
        this.loaded.push(t),
        this.loaded.length === this.loading.length && (this.isLoaded = !0)
    }
    resetRevolutions(t) {
        if (0 === Math.abs(t / H))
            return t;
        return t - Math.floor(Math.abs(t / H)) * Math.sign(t) * H
    }
    addListeners() {
        window.addEventListener("resize", this.handleResize),
        this.isStatic || (window.addEventListener("mouseup", this.handleMouseUp),
        window.addEventListener("mousemove", this.handleMouseMove),
        this.el.addEventListener("touchstart", this.handleTouchStart, {
            passive: !0
        }),
        window.addEventListener("touchmove", this.handleTouchMove),
        window.addEventListener("touchend", this.handleMouseUp),
        this.el.addEventListener("mousedown", this.handleMouseDown))
    }
    revealAnimation() {
        const t = this.isStatic ? 1 : a.easeOutQuart(this.opacityLoadPercent, 0, 1, 1);
        this.opacityLoadPercent += .005,
        this.targetOpacityBase = t * this.initGlobeOptions.opacity,
        this.globeRotationIncrement = .02 * (1 - t) + .001 * t,
        t > .999 && (this.isRevealed = !0)
    }
    autoRotateGlobe() {
        this.isDragging || this.isScrolling || this.isStatic || this.pauseRotate || (this.globeRotationBase -= this.globeRotationIncrement,
        this.globeContainer.rotation.y = this.globeRotationBase + this.globeRotationScrollAmount)
    }
    updateGlobeScale() {
        if (Math.abs(this.scale - this.targetScale) > .001 && (this.scale -= .1 * (this.scale - this.targetScale),
        this.globeFill.scale.set(this.scale, this.scale, this.scale),
        this.backgroundGradientUrl)) {
            const t = (1 + 2 * (1 - this.scale)) * this.backgroundGradientSize;
            this.backgroundGradient.scale.set(t, t, t)
        }
    }
    updateGlobeOpacity() {
        this.targetOpacity = Math.max(0, this.targetOpacityBase + this.targetOpacityScrollAmount);
        const t = Math.max(0, this.targetDotOpacityBase + this.targetOpacityScrollAmount);
        Math.abs(this.targetOpacity - this.globeFillMaterial.opacity) > .001 && (this.globeFillMaterial.opacity = this.targetOpacity,
        this.backgroundGradient && (this.backgroundGradient.material.opacity = this.targetOpacity),
        this.globeDots.material && (this.globeDots.material.uniforms.u_opacity_factor.value = t),
        this.currentLines && this.currentLines.forEach(t=>{
            t.material.uniforms.u_alpha.value = this.targetOpacity,
            t.circleMaterial1.opacity = this.targetOpacity,
            t.circleMaterial2.opacity = this.targetOpacity
        }
        ))
    }
    render(t=0) {
        this.frame = t,
        this.autoRotateGlobe(),
        this.updateGlobeScale(),
        this.updateGlobeOpacity(),
        !this.globeOff && this.isLoaded && (this.globeDots.animate(),
        this.isRevealed || (this.customRevealAnimation ? this.customRevealAnimation() : this.revealAnimation()),
        this.renderer.render(this.scene, this.camera)),
        this.renderAnimationFrame = requestAnimationFrame(()=>{
            this.isRevealed && this.isStatic && this.arcTexturesLoaded === this.arcTextures.length && this.isDiscTextureLoaded ? this.renderer.render(this.scene, this.camera) : this.render(t + 1)
        }
        )
    }
}
export {nt as Globe};
